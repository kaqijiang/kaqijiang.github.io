---
date: 2015-02-25 15:27:31
layout: post
title: swift基础--构造方法
category: Swift
tags: Swift
keywords: 构造方法 swift private 重载
description: swift基础知识
---


### 构造方法
```
class person: NSObject {
    
    var name: String
    
    override init() {
        self.name = "liMing"//先初始化，分配空间，再调用父类
        super.init()
    }
    
    init(name: String){//重载构造方法
        self.name = name
        super.init()
    }
}

//oc
- (instancetype)init {
	
	self = [super init];
	if(self){
	//doit
	}
	return self;
}

NSObject没有成员变量，只有一个属性isa
```

--
- swift先给属性赋值分配空间再初始化父类

- OC在初始化的时候先调用[super init] 再去初始化自己。

- OC比swift相当于是多循环了一次

--
- 如果实现了重载的构造方法，且没有实现override init()那么init()将不对外开放。默认为init()不能满足重载的构造方法。
- 非optional一定要先初始化成员变量

--
- 重写 override
	- 父类存在相同的方法
	- 子类重新编写父类方法的实现
- 重载
	- 函数名相同
	- 参数类型和个数不同
	
--
	 
```
class person: NSObject {
    
    var name: String? 
    private var title: String? //私有的
        
    init(dict: [String: AnyObjict]){

        super.init()
        //KVC是OC的方法，所以先调用super        
        setValuesForKeys(dict)
    }
    override func setValue(_ value: AnyObject?, forUndefinedKey key: String){
            //没有调用super  覆盖父类方法
        }
}
```
- 定义模型属性的时候，如果是对象，通常都是可选的
	- 在需要的时候创建
	- 避免写构造函数，可以简化代码
- 如果是基本数据类型，不能设置成可选的，而且要设置初始值，否则KVC会崩溃。
	- 因为Int是基本数据类型的结构体，OC中没有，OC只有基本数据类型。
- 在使用KVC之前，应该调用super.init保证对象实例化完成。
	- OC为什么要先调用super,因为OC在运行时给对象发送消息，那么就需要对象已经实例化完毕。
	
- 如果修饰成员变量的是 private,使用的KVC设置值的时候，同样无法设置。	
	- 设置private属性/方法，禁止外部访问的。
	- OC通常不会写private 只是在.m文件中写方法，OC通过运行时可以获取到。swift通过运行时也获取不到（可以获取到 ivar）, 所以KVC会崩溃。
- 如果定义基本类型为可选，运行时同样获取不到，所以使用KVC会同样崩溃

```
class person: NSObject {
    
    var name: String?
    var age: Int = 0
    var title: String?
    
    //使用运行时，获取当前类所属属性的数组
    class func PropertyList() -> [String] {
        var count: UInt32 = 0
        
        //获取类的属性类别，返回属性列表的数组，可选项
        //参数1 <#T##cls: AnyClass?##AnyClass?#> 所属的类 self
        //参数2 <#T##outCount: UnsafeMutablePointer<UInt32>?##UnsafeMutablePointer<UInt32>?#> 可变的UInt32 C语言指针
        //返回值 属性列表的数组，可选项

        let list = class_copyPropertyList(self, &count)

        for i in 0..<Int(count) {//转换方便取下标
            
            let pty = list?[i]
            // 获取‘属性’的名称，C语言的字符串
            //Int8 -> Byte -> Char => C语言的字符串
            let cName = property_getName(pty!)
            
            let name = String(utf8String: cName)
            print(name)
            
        }
        // 释放C语言对象
        //class_copyPropertyList You must free the array with free().
        free(list)
        return []
    }
}
```
	 


--